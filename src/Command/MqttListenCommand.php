<?php

namespace App\Command;

use App\Service\MqttService;
use App\Service\GameService;
use App\Service\NotifierService;
use App\Service\StateStorage;
use Symfony\Component\Console\Attribute\AsCommand;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Style\SymfonyStyle;
use Psr\Log\LoggerInterface;

/**
 * Komenda konsoli odp                        // Wy≈õlij ≈ºƒÖdanie ruchu do silnika na w≈Ça≈õciwym kanale
                        $this->mqtt->publish('move/engine/request', $this->pendingAiMoveRequest);iedzialna za nas≈Çuchiwanie komunikat√≥w MQTT i przekazywanie ich do GameService.
 * 
 * Ta komenda implementuje g≈Ç√≥wnƒÖ pƒôtlƒô komunikacyjnƒÖ systemu szachowego, nas≈ÇuchujƒÖc na nastƒôpujƒÖcych kana≈Çach MQTT:
 * - move/player: ruchy fizyczne z Raspberry Pi
 * - move/web: ruchy z aplikacji webowej
 * - move/ai: ruchy od silnika szachowego
 * - engine/move/confirmed: potwierdzenia legalnych ruch√≥w od silnika z nowym FEN
 * - engine/move/rejected: odrzucenia nielegalnych ruch√≥w od silnika z powodem
 * - move/possible_moves/request: ≈ºƒÖdania mo≈ºliwych ruch√≥w z aplikacji webowej
 * - engine/possible_moves/response: odpowiedzi z mo≈ºliwymi ruchami od silnika szachowego
 * - status/raspi: statusy Raspberry Pi (przekazywane do UI)
 * - status/engine: statusy silnika szachowego (przekazywane do UI)
 * - control/restart: sygna≈Çy restartu gry
 * - move/+: debug - wszystkie komunikaty move/* dla diagnostyki
 * 
 * Komenda przetwarza statusy komponent√≥w i przekazuje je do aplikacji webowej przez WebSocket,
 * mapujƒÖc r√≥≈ºne formaty status√≥w na ustandaryzowane komunikaty dla UI.
 */
#[AsCommand(
    name: 'app:mqtt-listen',
    description: 'Nas≈Çuchuje MQTT i przekazuje komunikaty do GameService'
)]
class MqttListenCommand extends Command
{
    /**
     * @param MqttService $mqtt Serwis MQTT do komunikacji z brokerem
     * @param GameService $game Serwis gry do przetwarzania ruch√≥w
     * @param NotifierService $notifier Serwis powiadomie≈Ñ do komunikacji z UI
     * @param StateStorage $state Serwis przechowywania stanu gry
     * @param LoggerInterface|null $logger Logger do zapisywania log√≥w (opcjonalny)
     */
    public function __construct(
        private MqttService $mqtt,
        private GameService $game,
        private NotifierService $notifier,
        private StateStorage $state,
        private ?LoggerInterface $logger = null,

        /** @var array Przechowuje informacje o ju≈º przetworzonych potwierdzeniach ruch√≥w */
        private array $lastProcessedMoveHash = [],

        /** @var string Przechowuje aktualny status Raspberry Pi */
        private string $raspiStatus = 'unknown',

        /** @var array Przechowuje informacje o oczekujƒÖcym ruchu AI */
        private array $pendingAiMoveRequest = [],

        /** @var bool Flaga oznaczajƒÖca czy czekamy na potwierdzenie ruchu przez Raspberry Pi */
        private bool $waitingForRaspiConfirmation = false,

        /** @var array Przechowuje oczekujƒÖce powiadomienie UI o ruchu AI */
        private array $pendingUiNotification = [],

        /** @var bool Flaga oznaczajƒÖca czy czekamy na cofniƒôcie nielegalnego ruchu fizycznego przez Raspberry Pi */
        private bool $waitingForMoveRevert = false

    ) {
        parent::__construct();
    }
    /**
     * Konfiguruje komendƒô - ustawia opis i parametry.
     * 
     * @return void
     */
    protected function configure(): void
    {
        $this->setDescription('Nas≈Çuchuje MQTT i przekazuje do GameService');
    }

    /**
     * G≈Ç√≥wna metoda wykonywania komendy - uruchamia pƒôtlƒô nas≈Çuchiwania MQTT.
     * 
     * Metoda ustanawia subskrypcje na wszystkie wymagane kana≈Çy MQTT i uruchamia
     * niesko≈ÑczonƒÖ pƒôtlƒô przetwarzania komunikat√≥w. Obs≈Çuguje b≈Çƒôdy po≈ÇƒÖczenia
     * i zapewnia mechanizmy odzyskiwania po awariach.
     * 
     * @param InputInterface $input Interfejs wej≈õciowy komendy
     * @param OutputInterface $output Interfejs wyj≈õciowy komendy
     * @return int Kod wyj≈õcia komendy (Command::SUCCESS lub Command::FAILURE)
     * @throws \Exception W przypadku krytycznych b≈Çƒôd√≥w MQTT
     */
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $io = new SymfonyStyle($input, $output);

        $io->title('MQTT Chess Listener');
        $io->info('Starting MQTT listener for chess game...');

        try {
            // Subskrybuj ruchy fizycznej planszy z Raspberry Pi
            $this->mqtt->subscribe('move/player', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');

                // Ignoruj ruchy podczas cofania nielegalnego ruchu
                if ($this->waitingForMoveRevert) {
                    $io->warning("[$timestamp] ‚ö†Ô∏è  <fg=yellow>Physical move IGNORED - waiting for illegal move revert confirmation</>");
                    $this->logger?->warning('MQTT: Physical move ignored - waiting for revert', [
                        'topic' => $topic,
                        'message' => $msg,
                        'timestamp' => $timestamp
                    ]);
                    return;
                }

                $io->text("[$timestamp] ÔøΩ <fg=green>Physical move received:</> $msg");

                $this->logger?->info('MQTT: Physical move received', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['from'], $decoded['to'])) {
                    try {
                        // Obs≈Çuga dodatkowych parametr√≥w dla specjalnych ruch√≥w fizycznych
                        $specialMove = $decoded['special_move'] ?? null;
                        $promotionPiece = $decoded['promotion_piece'] ?? null;
                        $availablePieces = $decoded['available_pieces'] ?? null;
                        $capturedPiece = $decoded['captured_piece'] ?? null;

                        // Ruch fizyczny - backend powiadamia UI i silnik
                        // GameService automatycznie wy≈õle ruch do silnika, wiƒôc nie robimy tego tutaj

                        // Wykonaj ruch w GameService
                        $this->game->playerMove(
                            $decoded['from'],
                            $decoded['to'],
                            true,
                            $specialMove,
                            $promotionPiece,
                            $availablePieces,
                            $capturedPiece
                        );

                        $moveDesc = "{$decoded['from']} ‚Üí {$decoded['to']}";
                        if ($specialMove) {
                            $moveDesc .= " ($specialMove)";
                        }
                        $io->text("    ‚úÖ <fg=green>Physical move processed:</> $moveDesc");

                        $this->logger?->info('Game: Physical move processed successfully', [
                            'from' => $decoded['from'],
                            'to' => $decoded['to'],
                            'special_move' => $specialMove,
                            'promotion_piece' => $promotionPiece,
                            'captured_piece' => $capturedPiece
                        ]);
                    } catch (\Exception $e) {
                        $io->error("    ‚ùå Failed to process physical move: " . $e->getMessage());
                        $this->logger?->error('Game: Physical move failed', [
                            'from' => $decoded['from'] ?? 'unknown',
                            'to' => $decoded['to'] ?? 'unknown',
                            'error' => $e->getMessage()
                        ]);
                    }
                } else {
                    $io->warning("    ‚ö†Ô∏è  Invalid physical move format");
                    $this->logger?->warning('MQTT: Invalid physical move format', ['message' => $msg]);
                }
            });

            // Subskrybuj ruchy z aplikacji webowej (publikowane przez backend gdy REST API jest wywo≈Çane)
            $this->mqtt->subscribe('move/web', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');

                // Ignoruj ruchy podczas cofania nielegalnego ruchu
                if ($this->waitingForMoveRevert) {
                    $io->warning("[$timestamp] ‚ö†Ô∏è  <fg=yellow>Web move IGNORED - waiting for illegal move revert confirmation</>");
                    $this->logger?->warning('MQTT: Web move ignored - waiting for revert', [
                        'topic' => $topic,
                        'message' => $msg,
                        'timestamp' => $timestamp
                    ]);
                    return;
                }

                $io->text("[$timestamp] üåê <fg=cyan>Web move received:</> $msg");

                $this->logger?->info('MQTT: Web move received', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['from'], $decoded['to'])) {
                    try {
                        // Obs≈Çuga dodatkowych parametr√≥w dla specjalnych ruch√≥w z aplikacji webowej
                        $specialMove = $decoded['special_move'] ?? null;
                        $promotionPiece = $decoded['promotion_piece'] ?? null;
                        $availablePieces = $decoded['available_pieces'] ?? null;
                        $capturedPiece = $decoded['captured_piece'] ?? null;

                        // Ruch z aplikacji web - backend powiadamia Raspberry Pi i silnik
                        // GameService automatycznie wy≈õle ruch do silnika, wiƒôc nie robimy tego tutaj

                        // Wykonaj ruch w GameService
                        $this->game->playerMove(
                            $decoded['from'],
                            $decoded['to'],
                            false,
                            $specialMove,
                            $promotionPiece,
                            $availablePieces,
                            $capturedPiece
                        );

                        $moveDesc = "{$decoded['from']} ‚Üí {$decoded['to']}";
                        if ($specialMove) {
                            $moveDesc .= " ($specialMove)";
                        }
                        $io->text("    ‚úÖ <fg=green>Web move processed:</> $moveDesc");

                        $this->logger?->info('Game: Web move processed successfully', [
                            'from' => $decoded['from'],
                            'to' => $decoded['to'],
                            'special_move' => $specialMove,
                            'promotion_piece' => $promotionPiece,
                            'captured_piece' => $capturedPiece
                        ]);
                    } catch (\Exception $e) {
                        $io->error("    ‚ùå Failed to process web move: " . $e->getMessage());
                        $this->logger?->error('Game: Web move failed', [
                            'from' => $decoded['from'] ?? 'unknown',
                            'to' => $decoded['to'] ?? 'unknown',
                            'error' => $e->getMessage()
                        ]);
                    }
                } else {
                    $io->warning("    ‚ö†Ô∏è  Invalid web move format");
                    $this->logger?->warning('MQTT: Invalid web move format', ['message' => $msg]);
                }
            });

            // Subskrybuj ruchy AI z silnika szachowego
            $this->mqtt->subscribe('move/ai', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] ü§ñ <fg=yellow>AI move received:</> $msg");

                $this->logger?->info('MQTT: AI move received', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['from'], $decoded['to'], $decoded['fen'], $decoded['next_player'])) {
                    try {
                        // Obs≈Çuga dodatkowych parametr√≥w dla specjalnych ruch√≥w AI
                        $specialMove = $decoded['special_move'] ?? null;
                        $additionalMoves = $decoded['additional_moves'] ?? null;
                        $promotionPiece = $decoded['promotion_piece'] ?? null;
                        $notation = $decoded['notation'] ?? null;
                        $givesCheck = $decoded['gives_check'] ?? false;
                        $gameStatus = $decoded['game_status'] ?? null;
                        $winner = $decoded['winner'] ?? null;
                        $capturedPiece = $decoded['captured_piece'] ?? null;

                        $this->game->aiMove(
                            $decoded['from'],
                            $decoded['to'],
                            $decoded['fen'],
                            $decoded['next_player'],
                            $specialMove,
                            $additionalMoves,
                            $promotionPiece,
                            $notation,
                            $givesCheck,
                            $gameStatus,
                            $winner,
                            $capturedPiece
                        );

                        $moveDesc = "{$decoded['from']} ‚Üí {$decoded['to']}";
                        if ($specialMove) {
                            $moveDesc .= " ($specialMove)";
                        }
                        if ($givesCheck) {
                            $moveDesc .= " - SZACH!";
                        }
                        if ($gameStatus && in_array($gameStatus, ['checkmate', 'stalemate', 'draw'])) {
                            $moveDesc .= " - KONIEC GRY ($gameStatus)";
                        }

                        $io->text("    ‚úÖ <fg=green>AI move processed:</> $moveDesc");

                        $this->logger?->info('Game: AI move processed successfully', [
                            'from' => $decoded['from'],
                            'to' => $decoded['to'],
                            'fen' => $decoded['fen'],
                            'next_player' => $decoded['next_player'],
                            'special_move' => $specialMove,
                            'gives_check' => $givesCheck,
                            'game_status' => $gameStatus
                        ]);
                    } catch (\Exception $e) {
                        $io->error("    ‚ùå Failed to process AI move: " . $e->getMessage());
                        $this->logger?->error('Game: AI move failed', [
                            'from' => $decoded['from'] ?? 'unknown',
                            'to' => $decoded['to'] ?? 'unknown',
                            'error' => $e->getMessage()
                        ]);
                    }
                } else {
                    $io->warning("    ‚ö†Ô∏è  Invalid AI move format (expected: from, to, fen, next_player)");
                    $this->logger?->warning('MQTT: Invalid AI move format', ['message' => $msg]);
                }
            });

            // Subskrybuj potwierdzenia ruch√≥w od silnika
            $this->mqtt->subscribe('engine/move/confirmed', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] ‚úÖ <fg=green>Move confirmed by engine:</> $msg");

                $this->logger?->info('MQTT: Move confirmed by engine', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['from'], $decoded['to'], $decoded['fen'], $decoded['next_player'])) {

                    // Wygeneruj hash dla tego ruchu
                    $moveHash = md5($decoded['from'] . $decoded['to'] . $decoded['fen']);

                    // Sprawd≈∫ czy to nie duplikat w kr√≥tkim odstƒôpie czasu
                    if (isset($this->lastProcessedMoveHash[$moveHash])) {
                        $lastTime = $this->lastProcessedMoveHash[$moveHash];
                        if (time() - $lastTime < 5) { // ignoruj duplikaty w ciƒÖgu 5 sekund
                            $io->text("    ‚ö†Ô∏è <fg=yellow>Ignoring duplicate move confirmation</>");
                            return;
                        }
                    }

                    // Zapisz czas przetworzenia tego ruchu
                    $this->lastProcessedMoveHash[$moveHash] = time();

                    // Wyczy≈õƒá stare hashe (starsze ni≈º 10 sekund)
                    $this->lastProcessedMoveHash = array_filter(
                        $this->lastProcessedMoveHash,
                        fn($time) => time() - $time < 10
                    );
                    try {
                        // Obs≈Çuga dodatkowych parametr√≥w dla specjalnych ruch√≥w
                        $physical = $decoded['physical'] ?? false;
                        $specialMove = $decoded['special_move'] ?? null;
                        $additionalMoves = $decoded['additional_moves'] ?? null;
                        $promotionPiece = $decoded['promotion_piece'] ?? null;
                        $notation = $decoded['notation'] ?? null;
                        $givesCheck = $decoded['gives_check'] ?? false;
                        $gameStatus = $decoded['game_status'] ?? null;
                        $winner = $decoded['winner'] ?? null;
                        $capturedPiece = $decoded['captured_piece'] ?? null;

                        // GameService bƒôdzie zarzƒÖdzaƒá ≈ºƒÖdaniami AI

                        $this->game->confirmMoveFromEngine(
                            $decoded['from'],
                            $decoded['to'],
                            $decoded['fen'],
                            $decoded['next_player'],
                            $physical,
                            $specialMove,
                            $additionalMoves,
                            $promotionPiece,
                            $notation,
                            $givesCheck,
                            $gameStatus,
                            $winner,
                            $capturedPiece
                        );

                        $moveDesc = "{$decoded['from']} ‚Üí {$decoded['to']}";
                        if ($specialMove) {
                            $moveDesc .= " ($specialMove)";
                        }
                        if ($givesCheck) {
                            $moveDesc .= " - SZACH!";
                        }
                        if ($gameStatus && in_array($gameStatus, ['checkmate', 'stalemate', 'draw'])) {
                            $moveDesc .= " - KONIEC GRY ($gameStatus)";
                        }

                        $io->text("    ‚úÖ <fg=green>Move confirmed:</> $moveDesc");

                        $this->logger?->info('Game: Move confirmed successfully', [
                            'from' => $decoded['from'],
                            'to' => $decoded['to'],
                            'fen' => $decoded['fen'],
                            'special_move' => $specialMove,
                            'gives_check' => $givesCheck,
                            'game_status' => $gameStatus
                        ]);
                    } catch (\Exception $e) {
                        $io->error("    ‚ùå Failed to confirm move: " . $e->getMessage());
                        $this->logger?->error('Game: Move confirmation failed', [
                            'error' => $e->getMessage()
                        ]);
                    }
                } else {
                    $io->warning("    ‚ö†Ô∏è  Invalid move confirmation format");
                    $this->logger?->warning('MQTT: Invalid move confirmation format', ['message' => $msg]);
                }
            });

            // Subskrybuj odrzucenia ruch√≥w od silnika
            $this->mqtt->subscribe('engine/move/rejected', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] ‚ùå <fg=red>Move rejected by engine:</> $msg");

                $this->logger?->info('MQTT: Move rejected by engine', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['from'], $decoded['to'], $decoded['reason'])) {
                    // Je≈õli odrzucony ruch by≈Ç fizyczny, ustaw flagƒô oczekiwania na cofniƒôcie
                    $isPhysical = $decoded['physical'] ?? false;
                    if ($isPhysical) {
                        $this->waitingForMoveRevert = true;
                        $io->text("    üö´ <fg=red>PHYSICAL move rejected - waiting for RasPi to revert the move</>");
                        $this->logger?->warning('MQTT: Physical move rejected, waiting for revert', [
                            'from' => $decoded['from'],
                            'to' => $decoded['to'],
                            'reason' => $decoded['reason']
                        ]);
                    }

                    try {
                        $this->game->rejectMoveFromEngine(
                            $decoded['from'],
                            $decoded['to'],
                            $decoded['reason'],
                            $decoded['physical'] ?? false
                        );
                        $io->text("    ‚ùå <fg=red>Move rejected:</> {$decoded['from']} ‚Üí {$decoded['to']} ({$decoded['reason']})");

                        $this->logger?->info('Game: Move rejected successfully', [
                            'from' => $decoded['from'],
                            'to' => $decoded['to'],
                            'reason' => $decoded['reason']
                        ]);
                    } catch (\Exception $e) {
                        $io->error("    ‚ùå Failed to reject move: " . $e->getMessage());
                        $this->logger?->error('Game: Move rejection failed', [
                            'error' => $e->getMessage()
                        ]);
                    }
                } else {
                    $io->warning("    ‚ö†Ô∏è  Invalid move rejection format");
                    $this->logger?->warning('MQTT: Invalid move rejection format', ['message' => $msg]);
                }
            });

            // Subskrybuj aktualizacje statusu Raspberry Pi
            $this->mqtt->subscribe('status/raspi', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] üì° <fg=blue>RasPi status:</> $msg");

                $this->logger?->info('MQTT: Raspberry Pi status received', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                // Zapisz status dla kontroli przep≈Çywu AI
                $decodedStatus = null;
                if (is_string($msg)) {
                    if (strtolower(trim($msg)) === 'ready' || strtolower(trim($msg)) === 'moving') {
                        $this->raspiStatus = strtolower(trim($msg));
                    } else {
                        // Pr√≥ba zdekodowania jako JSON
                        $decodedStatus = json_decode($msg, true);
                        if ($decodedStatus && isset($decodedStatus['status'])) {
                            $this->raspiStatus = strtolower(trim($decodedStatus['status']));
                        }
                    }
                }

                // Je≈õli status to "moving", ustaw flagƒô oczekiwania na potwierdzenie
                if ($this->raspiStatus === 'moving') {
                    // Rozr√≥≈ºnij czy to cofanie nielegalnego ruchu, czy normalny ruch
                    if ($this->waitingForMoveRevert) {
                        $io->text("    üîÑ <fg=red>RasPi cofa nielegalny ruch fizyczny - czekamy na zako≈Ñczenie...</>");
                        $this->logger?->info('MQTT: RasPi reverting illegal physical move');
                    } else {
                        $this->waitingForRaspiConfirmation = true;
                        $io->text("    üîÑ <fg=yellow>RasPi wykonuje ruch - czekamy na potwierdzenie</>");
                    }
                }

                // Przeka≈º status do UI przez WebSocket/Mercure
                try {
                    $processedStatus = $this->processStatusForUI($msg, 'raspberry_pi');

                    $this->notifier->broadcast([
                        'type' => 'raspi_status',
                        'data' => $processedStatus,
                        'timestamp' => $timestamp
                    ]);

                    $statusDisplay = $processedStatus['format'] === 'json'
                        ? json_encode($processedStatus['status'])
                        : $processedStatus['message'] ?? $msg;

                    $io->text("    ‚úÖ <fg=green>Status forwarded to UI:</> {$statusDisplay}");
                    $this->logger?->debug('MQTT: Raspberry Pi status forwarded to UI', ['processed_status' => $processedStatus]);

                    // Je≈õli status to "ready" i czekali≈õmy na cofniƒôcie nielegalnego ruchu
                    if ($this->raspiStatus === 'ready' && $this->waitingForMoveRevert) {
                        $io->success("    ‚úÖ <fg=green>RasPi zako≈Ñczy≈Ço cofanie nielegalnego ruchu - system odblokowany!</>");
                        $this->logger?->info('MQTT: Illegal move revert completed, system unlocked');

                        // Odblokuj system
                        $this->waitingForMoveRevert = false;

                        // Powiadom UI ≈ºe cofniƒôcie zosta≈Ço zako≈Ñczone i mo≈ºna wykonaƒá kolejny ruch
                        $this->notifier->broadcast([
                            'type' => 'revert_completed',
                            'message' => 'Illegal move has been reverted. Board is ready for next move.',
                            'timestamp' => $timestamp,
                            'status' => 'ready_for_move'
                        ]);

                        $io->text("    üì¢ <fg=green>UI notified: system ready for next move</>");
                    }

                    // Je≈õli status to "ready" i mamy oczekujƒÖce ≈ºƒÖdanie ruchu AI, uruchom je
                    // Dodatkowo sprawd≈∫ czy flaga waitingForRaspiConfirmation by≈Ça ustawiona (oznacza ≈ºe RasPi zako≈Ñczy≈Ço ruch)
                    if ($this->raspiStatus === 'ready' && !empty($this->pendingAiMoveRequest) && $this->waitingForRaspiConfirmation) {
                        $io->text("    ü§ñ <fg=yellow>RasPi zako≈Ñczy≈Ço ruch i jest gotowe, wysy≈Çam oczekujƒÖce ≈ºƒÖdanie ruchu AI</>");
                        $this->logger?->info('MQTT: Sending pending AI move request after RasPi ready', [
                            'pending_request' => $this->pendingAiMoveRequest
                        ]);

                        // Wy≈õlij ≈ºƒÖdanie ruchu do silnika
                        $this->mqtt->publish('move/engine/request', $this->pendingAiMoveRequest);

                        // Wyczy≈õƒá oczekujƒÖce ≈ºƒÖdanie i flagƒô oczekiwania
                        $this->pendingAiMoveRequest = [];
                        $this->waitingForRaspiConfirmation = false;
                    }

                    // Je≈õli status to "ready" i mamy oczekujƒÖce powiadomienie UI (po ruchu AI), wy≈õlij je
                    if ($this->raspiStatus === 'ready' && !empty($this->pendingUiNotification) && $this->waitingForRaspiConfirmation) {
                        $io->text("    üì¢ <fg=green>RasPi zako≈Ñczy≈Ço ruch AI, wysy≈Çam powiadomienie do UI</>");
                        $this->logger?->info('MQTT: Sending pending UI notification after RasPi ready', [
                            'notification' => $this->pendingUiNotification
                        ]);

                        // Wy≈õlij powiadomienie do UI przez Mercure
                        $notificationToSend = $this->pendingUiNotification;

                        // Je≈õli jest informacja o ko≈Ñcu gry, wy≈õlij osobne powiadomienie
                        if (isset($notificationToSend['game_over'])) {
                            $this->notifier->broadcast([
                                'type' => 'game_over',
                                'result' => $notificationToSend['game_over']['result'],
                                'winner' => $notificationToSend['game_over']['winner'],
                                'final_position' => $notificationToSend['game_over']['final_position'],
                                'moves_count' => $notificationToSend['game_over']['moves_count']
                            ]);
                            unset($notificationToSend['game_over']);
                        }

                        $this->notifier->broadcast($notificationToSend);

                        // Wyczy≈õƒá oczekujƒÖce powiadomienie i flagƒô oczekiwania
                        $this->pendingUiNotification = [];
                        $this->waitingForRaspiConfirmation = false;
                    }
                } catch (\Exception $e) {
                    $io->error("    ‚ùå Failed to forward RasPi status to UI: " . $e->getMessage());
                    $this->logger?->error('MQTT: Failed to forward RasPi status', [
                        'status' => $msg,
                        'error' => $e->getMessage()
                    ]);
                }
            });

            // Subskrybuj aktualizacje statusu silnika szachowego
            $this->mqtt->subscribe('status/engine', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] üß† <fg=magenta>Engine status:</> $msg");

                $this->logger?->info('MQTT: Chess engine status received', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                // Przeka≈º status do UI przez WebSocket/Mercure
                try {
                    $processedStatus = $this->processStatusForUI($msg, 'chess_engine');

                    $this->notifier->broadcast([
                        'type' => 'engine_status',
                        'data' => $processedStatus,
                        'timestamp' => $timestamp
                    ]);

                    $statusDisplay = $processedStatus['format'] === 'json'
                        ? json_encode($processedStatus['status'])
                        : $processedStatus['message'] ?? $msg;

                    $io->text("    ‚úÖ <fg=green>Status forwarded to UI:</> {$statusDisplay}");
                    $this->logger?->debug('MQTT: Chess engine status forwarded to UI', ['processed_status' => $processedStatus]);
                } catch (\Exception $e) {
                    $io->error("    ‚ùå Failed to forward engine status to UI: " . $e->getMessage());
                    $this->logger?->error('MQTT: Failed to forward engine status', [
                        'status' => $msg,
                        'error' => $e->getMessage()
                    ]);
                }
            });

            // POPRAWKA: Subskrybuj aktualizacje stanu (zamiast control/restart)
            // GameService publikuje state/update po resecie
            $this->mqtt->subscribe('state/update', function ($topic, $msg) use ($io) {
                static $lastStateHash = null;

                // Deduplication check
                $currentHash = md5($msg);
                if ($lastStateHash === $currentHash) {
                    $io->text("    ‚ö†Ô∏è <fg=yellow>Duplicate state update ignored</>");
                    $this->logger?->debug('MQTT: Duplicate state update ignored', ['hash' => $currentHash]);
                    return;
                }
                $lastStateHash = $currentHash;

                $timestamp = date('H:i:s');

                // Parsuj JSON i poka≈º tylko najwa≈ºniejsze informacje
                try {
                    $data = json_decode($msg, true);
                    if ($data && isset($data['fen'], $data['moves'])) {
                        $movesCount = count($data['moves']);
                        $currentPlayer = $data['turn'] ?? 'unknown';
                        $gameStatus = $data['game_status'] ?? 'playing';

                        // Sprawd≈∫ czy to reset
                        $startFen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
                        if ($data['fen'] === $startFen && empty($data['moves'])) {
                            $io->text("[$timestamp] üîÑ <fg=green>State update:</> Game reset detected");
                            $this->logger?->info('Game: Reset detected in state update');
                        } else {
                            $summary = "Moves: $movesCount | Turn: $currentPlayer | Status: $gameStatus";
                            $io->text("[$timestamp] üìä <fg=blue>State update:</> $summary");
                        }
                    } else {
                        $io->text("[$timestamp] üìä <fg=blue>State update:</> " . substr($msg, 0, 50) . "...");
                    }
                } catch (\Exception $e) {
                    $io->text("[$timestamp] üìä <fg=blue>State update:</> [parsing error]");
                    $this->logger?->warning('Failed to parse state update', ['error' => $e->getMessage()]);
                }

                $this->logger?->info('MQTT: State update received', [
                    'topic' => $topic,
                    'moves_count' => isset($data['moves']) ? count($data['moves']) : 0,
                    'current_player' => $data['turn'] ?? null,
                    'game_status' => $data['game_status'] ?? null,
                    'timestamp' => $timestamp
                ]);
            });

            // Subskrybuj ≈ºƒÖdania mo≈ºliwych ruch√≥w z aplikacji webowej
            $this->mqtt->subscribe('move/possible_moves/request', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] üîç <fg=cyan>Possible moves request:</> $msg");

                $this->logger?->info('MQTT: Possible moves request received', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['position'])) {
                    try {
                        // Przeka≈º ≈ºƒÖdanie do silnika szachowego wraz z aktualnym FEN
                        $currentState = $this->state->getState();
                        $this->mqtt->publish('engine/possible_moves/request', [
                            'position' => $decoded['position'],
                            'fen' => $currentState['fen']
                        ]);

                        $io->text("    ‚úÖ <fg=green>Request forwarded to engine:</> {$decoded['position']} (FEN: {$currentState['fen']})");

                        $this->logger?->info('MQTT: Possible moves request forwarded to engine', [
                            'position' => $decoded['position'],
                            'fen' => $currentState['fen']
                        ]);
                    } catch (\Exception $e) {
                        $io->error("    ‚ùå Failed to forward request to engine: " . $e->getMessage());
                        $this->logger?->error('MQTT: Failed to forward possible moves request', [
                            'error' => $e->getMessage(),
                            'position' => $decoded['position'] ?? 'unknown'
                        ]);
                    }
                } else {
                    $io->warning("    ‚ö†Ô∏è Invalid possible moves request format");
                    $this->logger?->warning('MQTT: Invalid possible moves request format', [
                        'message' => $msg
                    ]);
                }
            });

            // Subskrybuj odpowiedzi mo≈ºliwych ruch√≥w od silnika szachowego
            $this->mqtt->subscribe('engine/possible_moves/response', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] üìã <fg=cyan>Possible moves response from engine:</> $msg");

                $this->logger?->info('MQTT: Possible moves response received from engine', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['position'], $decoded['moves'])) {
                    try {
                        // DODAJ DODATKOWE LOGOWANIE
                        $broadcastData = [
                            'type' => 'possible_moves',
                            'position' => $decoded['position'],
                            'moves' => $decoded['moves']
                        ];

                        $io->text("    üîÑ <fg=yellow>Broadcasting to UI:</> " . json_encode($broadcastData));
                        $this->logger?->info('MQTT: Broadcasting possible moves to UI', $broadcastData);

                        // Przeka≈º odpowied≈∫ do aplikacji webowej przez WebSocket
                        $this->notifier->broadcast($broadcastData);

                        $movesCount = count($decoded['moves']);
                        $io->text("    ‚úÖ <fg=green>Response sent to webapp:</> {$decoded['position']} ‚Üí $movesCount moves");

                        $this->logger?->info('MQTT: Possible moves response sent to webapp', [
                            'position' => $decoded['position'],
                            'moves_count' => $movesCount,
                            'moves' => $decoded['moves']
                        ]);
                    } catch (\Exception $e) {
                        $io->error("    ‚ùå Failed to send response to webapp: " . $e->getMessage());
                        $this->logger?->error('MQTT: Failed to send possible moves response to webapp', [
                            'error' => $e->getMessage(),
                            'position' => $decoded['position'] ?? 'unknown'
                        ]);
                    }
                } else {
                    $io->warning("    ‚ö†Ô∏è Invalid possible moves response format from engine");
                    $this->logger?->warning('MQTT: Invalid possible moves response format from engine', [
                        'message' => $msg
                    ]);
                }
            });

            // Subskrybuj aktualizacje logu ruch√≥w
            $this->mqtt->subscribe('log/update', function ($topic, $msg) use ($io) {
                static $lastLogHash = null;

                // Deduplication check
                $currentHash = md5($msg);
                if ($lastLogHash === $currentHash) {
                    $io->text("    ‚ö†Ô∏è <fg=yellow>Duplicate log update ignored</>");
                    $this->logger?->debug('MQTT: Duplicate log update ignored', ['hash' => $currentHash]);
                    return;
                }
                $lastLogHash = $currentHash;

                $timestamp = date('H:i:s');

                // Parsuj JSON i poka≈º tylko liczbƒô ruch√≥w
                try {
                    $data = json_decode($msg, true);
                    if ($data && isset($data['moves'])) {
                        $moveCount = count($data['moves']);
                        $lastMove = !empty($data['moves']) ? end($data['moves']) : null;

                        if ($lastMove && isset($lastMove['from'], $lastMove['to'])) {
                            $lastMoveStr = $lastMove['from'] . '‚Üí' . $lastMove['to'];
                            $io->text("[$timestamp] üìù <fg=yellow>Log update:</> $moveCount moves (last: $lastMoveStr)");
                        } else {
                            $io->text("[$timestamp] üìù <fg=yellow>Log update:</> $moveCount moves");
                        }
                    } else {
                        $io->text("[$timestamp] üìù <fg=yellow>Log update:</> [no moves data]");
                    }
                } catch (\Exception $e) {
                    $io->text("[$timestamp] üìù <fg=yellow>Log update:</> [parsing error]");
                }

                $this->logger?->info('MQTT: Log update received', [
                    'topic' => $topic,
                    'moves_count' => isset($data['moves']) ? count($data['moves']) : 0,
                    'timestamp' => $timestamp
                ]);
            });

            // Subskrybuj potwierdnienia resetu od silnika
            $this->mqtt->subscribe('engine/reset/confirmed', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] üîÑ <fg=yellow>Engine reset confirmed:</> $msg");

                $this->logger?->info('MQTT: Engine reset confirmed', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                try {
                    $decoded = json_decode($msg, true);
                    if ($decoded && isset($decoded['fen']) && $decoded['type'] === 'reset_confirmed') {
                        $oldFEN = $this->state->getState()['fen'] ?? 'unknown';

                        $this->logger?->info('Updating StateStorage with engine reset FEN', [
                            'old_fen' => $oldFEN,
                            'new_fen' => $decoded['fen']
                        ]);

                        // Pe≈Çny reset StateStorage (nie tylko FEN!)
                        $this->state->reset();
                        $this->state->setCurrentFen($decoded['fen']);

                        // Teraz wy≈õlij zaktualizowany stan do frontendu
                        $resetState = $this->state->getState();
                        $this->mqtt->publish('state/update', $resetState);

                        // Wy≈õlij log update z dodatkowym polem reset, ≈ºeby uniknƒÖƒá deduplication
                        $this->mqtt->publish('log/update', [
                            'moves' => $resetState['moves'],
                            'reset' => true,
                            'timestamp' => time()
                        ]);

                        $io->text("    ‚úÖ <fg=green>StateStorage synchronized with engine FEN and frontend updated</>");

                        $this->logger?->info('StateStorage synchronized and frontend updated', [
                            'old_fen' => $oldFEN,
                            'new_fen' => $decoded['fen'],
                            'moves_count' => count($resetState['moves']),
                            'reset_moves_should_be_empty' => empty($resetState['moves']) ? 'YES' : 'NO'
                        ]);
                    }
                } catch (\Exception $e) {
                    $io->error("    ‚ùå Failed to process engine reset confirmation: " . $e->getMessage());
                    $this->logger?->error('MQTT: Engine reset confirmation failed', [
                        'error' => $e->getMessage(),
                        'message' => $msg
                    ]);
                }
            });

            // Subskrybuj wewnƒôtrzny temat ≈ºƒÖdania ruchu AI (do kontroli przep≈Çywu)
            $this->mqtt->subscribe('internal/request_ai_move', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] ü§ñ <fg=yellow>AI move request received:</> $msg");

                $this->logger?->info('MQTT: Internal AI move request received', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['type']) && $decoded['type'] === 'request_ai_move' && isset($decoded['fen'])) {
                    // Zawsze zapisz ≈ºƒÖdanie do kolejki - bƒôdzie wys≈Çane gdy RasPi potwierdzi gotowo≈õƒá po ruchu
                    $io->text("    üö¶ <fg=yellow>Zapisujƒô ≈ºƒÖdanie AI - czekam na potwierdzenie ruchu przez RasPi</>");

                    // Zapisz ≈ºƒÖdanie do wykonania po potwierdzeniu przez RasPi
                    $this->pendingAiMoveRequest = $decoded;

                    // Ustaw flagƒô oczekiwania na potwierdzenie - bƒôdzie zresetowana gdy RasPi wy≈õle "moving"
                    // i ustawiona ponownie na false gdy RasPi wy≈õle "ready"

                    $this->logger?->info('MQTT: AI move request queued, waiting for RasPi to complete move', [
                        'fen' => $decoded['fen'],
                        'raspi_status' => $this->raspiStatus,
                        'waiting_for_confirmation' => $this->waitingForRaspiConfirmation
                    ]);
                } else {
                    $io->warning("    ‚ö†Ô∏è  Invalid AI move request format");
                    $this->logger?->warning('MQTT: Invalid AI move request format', ['message' => $msg]);
                }
            });

            // Subskrybuj wewnƒôtrzny temat oczekujƒÖcych powiadomie≈Ñ UI (po ruchu AI)
            $this->mqtt->subscribe('internal/pending_ui_notification', function ($topic, $msg) use ($io) {
                $timestamp = date('H:i:s');
                $io->text("[$timestamp] üì¢ <fg=cyan>UI notification queued (waiting for RasPi):</> $msg");

                $this->logger?->info('MQTT: UI notification queued, waiting for RasPi confirmation', [
                    'topic' => $topic,
                    'message' => $msg,
                    'timestamp' => $timestamp
                ]);

                $decoded = json_decode($msg, true);
                if ($decoded && isset($decoded['type'])) {
                    // Zapisz powiadomienie do wys≈Çania po potwierdzeniu przez RasPi
                    $this->pendingUiNotification = $decoded;

                    $io->text("    üìã <fg=yellow>Powiadomienie zapisane - czekam na potwierdzenie RasPi</>");

                    $this->logger?->info('MQTT: UI notification stored, waiting for RasPi ready', [
                        'notification_type' => $decoded['type']
                    ]);
                } else {
                    $io->warning("    ‚ö†Ô∏è  Invalid UI notification format");
                    $this->logger?->warning('MQTT: Invalid UI notification format', ['message' => $msg]);
                }
            });

            // Debug logging is now handled by specific subscriptions

            $io->success('MQTT subscriptions established');
            $io->comment('Subscribed to: move/player, move/web, move/ai, engine/move/confirmed, engine/move/rejected, status/raspi, status/engine, state/update, move/possible_moves/request, engine/possible_moves/response, log/update, engine/reset/confirmed, internal/request_ai_move, internal/pending_ui_notification');
            $io->comment('Listening for moves and status updates... Press Ctrl+C to stop');

            $this->logger?->info('MQTT Listener started successfully');

            $loopCount = 0;

            // G≈Ç√≥wna pƒôtla z lepszƒÖ obs≈ÇugƒÖ b≈Çƒôd√≥w
            while (true) {
                try {
                    $this->mqtt->loop();
                    $loopCount++;

                    // Loguj sygna≈Ç ≈ºycia co 1000 iteracji (mniej wiƒôcej co ~1.7 minuty)
                    if ($loopCount % 1000 === 0) {
                        $io->text("[" . date('H:i:s') . "] üíì <fg=blue>Heartbeat - Loop #$loopCount</>");
                        $this->logger?->debug('MQTT: Heartbeat', ['loop_count' => $loopCount]);
                    }

                    usleep(100000); // 100ms op√≥≈∫nienie

                } catch (\Exception $e) {
                    $io->error("MQTT loop error: " . $e->getMessage());
                    $this->logger?->error('MQTT: Loop error', [
                        'error' => $e->getMessage(),
                        'loop_count' => $loopCount
                    ]);

                    // Poczekaj przed ponownƒÖ pr√≥bƒÖ
                    $io->comment('Waiting 5 seconds before retry...');
                    sleep(5);

                    // Spr√≥buj siƒô po≈ÇƒÖczyƒá ponownie lub przerwij po zbyt wielu b≈Çƒôdach
                    throw $e;
                }
            }
        } catch (\Exception $e) {
            $io->error('MQTT Listener failed: ' . $e->getMessage());
            $this->logger?->critical('MQTT Listener crashed', [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);
            return Command::FAILURE;
        }

        return Command::SUCCESS;
    }

    /**
     * Przetwarza i mapuje status komponentu na format zrozumia≈Çy dla UI.
     * 
     * Funkcja interpretuje r√≥≈ºne formaty status√≥w (string, JSON) i mapuje je
     * na ustandaryzowane formaty z dodatkowymi metadanymi dla aplikacji webowej.
     * 
     * @param string $rawStatus Surowy status otrzymany z MQTT
     * @param string $component Nazwa komponentu ('raspberry_pi' lub 'chess_engine')
     * @return array Przetworzony status z metadanymi
     */
    private function processStatusForUI(string $rawStatus, string $component): array
    {
        // Spr√≥buj zdekodowaƒá jako JSON
        $statusData = json_decode($rawStatus, true);

        if ($statusData && is_array($statusData)) {
            // Status w formacie JSON - zachowaj wszystkie dane
            return [
                'status' => $statusData,
                'format' => 'json',
                'component' => $component
            ];
        }

        // Status w formacie string - zmapuj na standardowe znaczenia
        $processedStatus = [
            'raw' => $rawStatus,
            'format' => 'string',
            'component' => $component
        ];

        // Mapowanie status√≥w wed≈Çug dokumentacji
        switch (strtolower(trim($rawStatus))) {
            case 'ready':
                $processedStatus['state'] = 'ready';
                $processedStatus['message'] = $component === 'raspberry_pi'
                    ? 'Raspberry Pi is ready for commands'
                    : 'Chess engine is ready for moves';
                $processedStatus['severity'] = 'info';
                break;

            case 'moving':
                $processedStatus['state'] = 'busy';
                $processedStatus['message'] = 'Raspberry Pi is executing a physical move';
                $processedStatus['severity'] = 'info';
                break;

            case 'thinking':
                $processedStatus['state'] = 'busy';
                $processedStatus['message'] = 'Chess engine is calculating the next move';
                $processedStatus['severity'] = 'info';
                break;

            case 'error':
                $processedStatus['state'] = 'error';
                $processedStatus['message'] = $component === 'raspberry_pi'
                    ? 'Raspberry Pi encountered an error'
                    : 'Chess engine encountered an error';
                $processedStatus['severity'] = 'error';
                break;

            case 'analyzing':
                $processedStatus['state'] = 'busy';
                $processedStatus['message'] = 'Chess engine is analyzing the position';
                $processedStatus['severity'] = 'info';
                break;

            default:
                $processedStatus['state'] = 'unknown';
                $processedStatus['message'] = "Unknown status: {$rawStatus}";
                $processedStatus['severity'] = 'warning';
        }

        return $processedStatus;
    }
}